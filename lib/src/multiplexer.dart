import 'dart:async';
import 'dart:io';
import 'dart:typed_data';

import 'package:dart_udx/src/cid.dart';
import 'package:dart_udx/src/packet.dart';
import 'package:dart_udx/src/socket.dart';
import 'package:meta/meta.dart';
import 'package:dart_udx/src/stream.dart';
import 'package:dart_udx/udx.dart';

/// A class that demultiplexes incoming UDX packets to the correct `UDPSocket`.
///
/// The `UDXMultiplexer` listens on a single `RawDatagramSocket` and forwards
/// packets to the appropriate `UDPSocket` instance based on their destination
/// Connection ID (CID).
class UDXMultiplexer {
  UDXMultiplexer(this.socket) {
    _listen();
  }

  /// The underlying UDP socket that this multiplexer listens on.
  final RawDatagramSocket socket;

  final _connectionsController = StreamController<UDPSocket>.broadcast();

  /// A stream of incoming UDX sockets.
  Stream<UDPSocket> get connections => _connectionsController.stream;

  /// A map of active connections, keyed by their local Connection ID.
  @visibleForTesting
  final Map<ConnectionId, UDPSocket> socketsByCid = {};
  @visibleForTesting
  final Map<String, UDPSocket> socketsByPeer = {};

  /// Starts listening for incoming datagrams and routes them.
  void _listen() {
    socket.listen((event) {
      if (event == RawSocketEvent.read) {
        final datagram = socket.receive();
        if (datagram == null) return;

        final data = datagram.data;
        if (data.length < 28) return; // Not a valid UDX packet

        // Extract the destination CID from the packet header
        final destinationCid = ConnectionId(data.sublist(0, 8));

        // Route the packet to the correct socket
        final socketConnection = socketsByCid[destinationCid];

        if (socketConnection != null) {
          // print('[MUX] Forwarding packet to existing UDPSocket');
          socketConnection.handleIncomingDatagram(datagram.data, datagram.address, datagram.port);
        } else {
          try {
            final packet = UDXPacket.fromBytes(data);
            final isNewConnection = packet.frames
                .whereType<StreamFrame>()
                .any((frame) => frame.isSyn);

            if (isNewConnection) {
              // print('[MUX] SYN packet detected. Creating new UDPSocket.');
              // This is a new connection attempt.
              // The localCid should be generated by the server, not taken from the client's packet.
              final newSocket = createSocket(
                UDX(), // This is not ideal, but for the test it's ok
                datagram.address.address,
                datagram.port,
                localCid: destinationCid, // Use the CID from the SYN packet
                remoteCid: packet.sourceCid,
              );
              // THE FIX: Map the temporary destination CID to the new socket
              // to handle retransmissions during the handshake.
              socketsByCid[destinationCid] = newSocket;
              _connectionsController.add(newSocket);
              newSocket.handleIncomingDatagram(datagram.data, datagram.address, datagram.port);
            }
          } catch (e) {
            // Not a valid UDX packet, ignore.
          }
        }
      }
    });
  }

  /// Closes the multiplexer and all associated sockets.
  void close() {
    // Create a copy of the list of sockets to avoid concurrent modification
    final socketsToClose = List<UDPSocket>.from(socketsByCid.values);
    for (final s in socketsToClose) {
      s.close();
    }
    socketsByCid.clear();
    socket.close();
    _connectionsController.close();
  }

  /// Sends a datagram to the specified address and port.
  void send(Uint8List data, InternetAddress address, int port) {
    socket.send(data, address, port);
  }

  /// Removes a socket from the multiplexer's management.
  void removeSocket(ConnectionId localCid) {
    final socket = socketsByCid.remove(localCid);
    if (socket != null) {
      final peerKey = '${socket.remoteAddress.address}:${socket.remotePort}';
      socketsByPeer.remove(peerKey);
    }
  }

  /// Registers an existing socket with this multiplexer.
  /// Used for connection migration.
  void addSocket(UDPSocket socket) {
    if (socketsByCid.containsKey(socket.cids.localCid)) {
      // This case should be handled by the caller, e.g., by closing the old socket.
      // For now, we'll just log it.
      print('Warning: CID collision detected in addSocket.');
      return;
    }
    socketsByCid[socket.cids.localCid] = socket;
  }

  /// Creates or retrieves a `UDPSocket` for a given peer.
  UDPSocket createSocket(
    UDX udx,
    String host,
    int port, {
    ConnectionId? localCid,
    ConnectionId? remoteCid,
  }) {
    final peerKey = '$host:$port';
    if (socketsByPeer.containsKey(peerKey)) {
      return socketsByPeer[peerKey]!;
    }

    // For now, we'll create a new socket for each peer.
    // A more advanced implementation would handle CID reuse.
    final remoteAddress = InternetAddress(host);
    final effectiveLocalCid = localCid ?? ConnectionId.random();
    final effectiveRemoteCid = remoteCid ?? ConnectionId.random();
    final cids = ConnectionCids(effectiveLocalCid, effectiveRemoteCid);

    final newSocket = UDPSocket(
      udx: udx,
      multiplexer: this,
      remoteAddress: remoteAddress,
      remotePort: port,
      cids: cids,
    );

    socketsByCid[effectiveLocalCid] = newSocket;
    socketsByPeer[peerKey] = newSocket;
    return newSocket;
  }

  // --- Test Hooks ---
  Map<ConnectionId, UDPSocket> getSocketsForTest() => socketsByCid;

  void handleIncomingDatagramForTest(
      Uint8List data, InternetAddress address, int port) {
    // This is a simplified version of the logic in _listen for test purposes
    if (data.length < 28) return;

    final destinationCid = ConnectionId(data.sublist(0, 8));
    final socketConnection = socketsByCid[destinationCid];

    if (socketConnection != null) {
      socketConnection.handleIncomingDatagram(data, address, port);
    } else {
      try {
        final packet = UDXPacket.fromBytes(data);
        final isNewConnection =
            packet.frames.whereType<StreamFrame>().any((frame) => frame.isSyn);

        if (isNewConnection) {
          final newSocket = createSocket(
            UDX(),
            address.address,
            port,
            localCid: destinationCid, // Use the CID from the SYN packet
            remoteCid: packet.sourceCid,
          );
          // THE FIX: Map the temporary destination CID to the new socket
          // to handle retransmissions during the handshake.
          socketsByCid[destinationCid] = newSocket;
          _connectionsController.add(newSocket);
          newSocket.handleIncomingDatagram(data, address, port);
        }
      } catch (e) {
        // Ignore
      }
    }
  }
}
